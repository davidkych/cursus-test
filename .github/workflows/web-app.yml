# .github/workflows/web-app.yml
name: Web-App Reusable

on:
  workflow_call:
    inputs:
      RG:          { required: true, type: string }
      APP:         { required: true, type: string }
      TIMEOUT:     { required: true, type: number }
      COSMOS:      { required: true, type: string }
      SCHED_FUNC:  { required: true, type: string }
    secrets:
      AZURE_CREDENTIALS: { required: true }
      JWT_SECRET:        { required: true }

jobs:
  deploy-web-app:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - uses: actions/setup-python@v4
        with:
          python-version: "3.9"
          cache: pip

      # â”€â”€ Vendor deps (retry + verify) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Vendor deps
        shell: bash
        run: |
          set -eo pipefail
          python -m pip install --upgrade pip

          VENV="src/.python_packages/lib/site-packages"          # â† Azure-expected path

          for attempt in 1 2 3; do
            echo "ğŸ“¦ pip install attempt $attempt"
            if python -m pip install --no-cache-dir --progress-bar off \
                 --target "$VENV" \
                 -r src/requirements.txt; then
              break
            fi
            echo "âš ï¸ pip install failed â€“ retrying in $((attempt*15)) s"
            sleep $((attempt*15))
          done

          export PYTHONPATH="$PWD/$VENV${PYTHONPATH:+:$PYTHONPATH}"
          python -m pip check
          python - <<'PY'
          import importlib, sys
          for pkg in ("uvicorn", "fastapi", "gunicorn"):
              try:
                  importlib.import_module(pkg)
                  print(f"âœ… import {pkg}")
              except ImportError as e:
                  sys.stderr.write(str(e) + "\n")
                  sys.exit(1)
          PY

      - uses: azure/login@v1
        with:
          auth-type: SERVICE_PRINCIPAL
          creds:     ${{ secrets.AZURE_CREDENTIALS }}

      # â”€â”€ MSI â†’ Cosmos role --------------------------------------------------
      - name: Grant Cosmos Data Contributor to Web-App MSI
        env:
          RG:     ${{ inputs.RG }}
          APP:    ${{ inputs.APP }}
          COSMOS: ${{ inputs.COSMOS }}
        run: |
          set -eo pipefail
          principalId=$(az webapp identity show \
              --resource-group "$RG" --name "$APP" --query principalId -o tsv)

          roleId=$(az cosmosdb sql role definition list \
              --resource-group "$RG" --account-name "$COSMOS" \
              --query "[?roleName=='Cosmos DB Built-in Data Contributor'].id" -o tsv)

          az cosmosdb sql role assignment create \
              --resource-group "$RG" --account-name "$COSMOS" \
              --principal-id "$principalId" --role-definition-id "$roleId" --scope "/"

      # â”€â”€ App settings: set ONLY deltas; leave infra-owned values to Bicep ---
      - name: Configure Web-App settings (secrets & runtime only)
        shell: bash
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          set -eo pipefail

          # Minimal settings here to avoid extra restarts pre-deploy.
          # WEBSITE_RUN_FROM_PACKAGE=1 ensures atomic package mount (no rsync temp dir).
          cat > appsettings.json <<JSON
          {
            "WEBSITE_RUN_FROM_PACKAGE": "1",
            "PYTHONPATH": "/home/site/wwwroot/.python_packages/lib/site-packages",
            "JWT_SECRET": "$JWT_SECRET",
            "USERS_CONTAINER": "users"
          }
          JSON

          az webapp config appsettings set \
            -g ${{ inputs.RG }} \
            -n ${{ inputs.APP }} \
            --settings @appsettings.json

          az webapp config set -g ${{ inputs.RG }} -n ${{ inputs.APP }} --always-on true
          az webapp log config -g ${{ inputs.RG }} -n ${{ inputs.APP }} \
            --application-logging filesystem \
            --detailed-error-messages true \
            --failed-request-tracing true

      # â”€â”€ Wait for restart after settings change -----------------------------
      - name: Wait for web-app to finish restarting
        shell: bash
        run: |
          set -eo pipefail
          echo "âŒ› Waiting for restart â€¦"
          for i in {1..36}; do
            code=$(curl -s -o /dev/null -w '%{http_code}' \
                     "https://${{ inputs.APP }}.azurewebsites.net/healthz" || true)
            [[ "$code" == "200" ]] && { echo "âœ… healthy"; exit 0; }
            sleep 5
          done
          echo "âš  still not healthy after 3 min â€“ continuing"

      # â”€â”€ Mark deploy start time (UTC) ---------------------------------------
      - name: Mark deploy start time
        id: mark_start
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import datetime, os
          now = datetime.datetime.utcnow().replace(microsecond=0)
          iso = now.isoformat() + "Z"
          epoch = int(now.timestamp())
          print(f"ğŸ“ Deploy start (UTC): {iso}")
          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
              print(f"start_iso={iso}", file=fh)
              print(f"start_epoch={epoch}", file=fh)
          PY

      # â”€â”€ Prepare Python log filter script -----------------------------------
      - name: Prepare Python log filter
        shell: bash
        run: |
          set -euo pipefail
          cat > filter_logs.py <<'PY'
          import os, sys, re, datetime

          START_EPOCH = int(os.environ.get("START_EPOCH", "0"))

          iso_re = re.compile(r'(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})')
          us_re  = re.compile(r'(\d{2}/\d{2}/\d{4})\s+(\d{2}:\d{2}:\d{2})')

          def parse_epoch(line: str):
              s = line.lstrip()
              if s.startswith("WARNING: "):
                  s = s[9:]
              m = iso_re.search(s)
              if m:
                  try:
                      dt = datetime.datetime.fromisoformat(m.group(1))
                      return int(dt.replace(tzinfo=datetime.timezone.utc).timestamp())
                  except Exception:
                      return None
              m = us_re.search(s)
              if m:
                  try:
                      dt = datetime.datetime.strptime(f"{m.group(1)} {m.group(2)}", "%m/%d/%Y %H:%M:%S")
                      return int(dt.replace(tzinfo=datetime.timezone.utc).timestamp())
                  except Exception:
                      return None
              return None

          printed_after = False
          for raw in sys.stdin:
              line = raw.rstrip("\n")
              ep = parse_epoch(line)
              if ep is not None:
                  if ep >= START_EPOCH:
                      print(line)
                      printed_after = True
              else:
                  if printed_after:
                      print(line)
          PY
                    python -V

      # â”€â”€ ZIP deploy (Run-From-Package friendly) -----------------------------
      - name: ZIP-deploy FastAPI web-app
        shell: bash
        run: |
          set -eo pipefail
          cd src && zip -qr ../app.zip . && cd ..
          echo "â³ initial warm-up 60 s â€¦"; sleep 60

          success=false
          DEPLOY_URL="https://${{ inputs.APP }}.scm.azurewebsites.net/api/deployments/latest"

          for attempt in 1 2 3; do
            echo "ğŸš€ ZIP-deploy attempt $attempt"
            if az webapp deploy -g ${{ inputs.RG }} -n ${{ inputs.APP }} \
                                --src-path app.zip --type zip --timeout 600; then
              echo "ğŸ“¡ streaming container log (filtered since ${{ steps.mark_start.outputs.start_iso }}) â€¦"
              export START_EPOCH="${{ steps.mark_start.outputs.start_epoch }}"
              # Save raw log and print only lines at/after START_EPOCH
              timeout 120s az webapp log tail -g ${{ inputs.RG }} -n ${{ inputs.APP }} \
                | tee live.log \
                | python filter_logs.py \
                | tee live.filtered.log || true

              sleep 15

              code=$(curl -s -o /dev/null -w '%{http_code}' \
                       "https://${{ inputs.APP }}.azurewebsites.net/healthz" || true)
              if [[ "$code" == "200" ]]; then
                success=true
                break
              fi
              echo "âš  unhealthy (HTTP $code) â€“ backing off"
            else
              echo "âš  ZIP-deploy attempt $attempt failed â€“ investigate at $DEPLOY_URL"
            fi
            sleep $((attempt*45))
          done

          if ! $success; then
            echo "ğŸ’¥ web-app deploy failed â€“ investigate at $DEPLOY_URL"
            exit 1
          fi

      # â”€â”€ Verify health endpoint (final gate) --------------------------------
      - name: Verify web-app /healthz
        shell: bash
        run: |
          set -eo pipefail
          echo "ğŸ” Final health probe â€¦"
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w '%{http_code}' \
                     "https://${{ inputs.APP }}.azurewebsites.net/healthz" || true)
            [[ "$code" == "200" ]] && { echo "âœ… health check passed"; exit 0; }
            echo "âŒ› still HTTP $code â€“ retrying"
            sleep 5
          done
          echo "ğŸ’¥ health check failed after 150 s"
          exit 1

      # â”€â”€ Upload logs on failure (raw + filtered) ----------------------------
      - if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: webapp-log
          path: |
            live.log
            live.filtered.log
